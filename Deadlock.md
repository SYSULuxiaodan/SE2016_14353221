#Lab4 死锁 #####
####一、死锁形成的洗个条件
多个进程在调度过程中可能形成死锁，而形成死锁的有四个条件，如下：
>1、互斥条件：即一个资源每次只能被一个进程使用，不同同时被多个进程使用。
>2、请求与保持条件：一个进程因为因请求资源而阻塞时，对已获得的资源保持不放。
>3、不剥夺条件：进程已获得的资源，在未使用完之前，不能对其强行剥夺
>4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源的关系。
上述四个条件存在，比如进程A拥有资源A，同时需要资源B，才能执行，而资源B被进程B所拥有，而进程B又需要资源C才能执行，资源C被进程C所拥有，但是，进程C需要资源A才能执行。所以这个时候，进程A会请求资源B，进程B会请求资源C。进程C会请求资源A，它们之间形成可一种头尾相接的环路关系。但是由于请求与保持条件，所以进程A，B，C未能执行之前，不会释放资源，而一个资源又不能同时被多个进程拥有，也不能被强行剥夺，所以资源B无法给进程A，资源C无法给进程B，资源A无法给进程C。这样导致进程A、B、C一直处在请求资源而又得不到所求资源的状态，所以形成了一种死锁的状态。

####二、死锁停在第几次？以及对程序产生死锁的解释
根据实验步骤，在ubuntu下跑了，我把count值一直调到50万，把循环次数定到了1000还没有死锁，所以在windows运行了。我定义的循环次数是200次，如下运行到173次的时候停止运行了。死锁停在了第173次。运行运行结果如下：
！[picture1](https://github.com/SYSULuxiaodan/SE2016_14353221/blob/master/picture41.png)

如上图所示，死锁停在了第173次。
下面解释下所用程序产生死锁的解释。
首先解释下代码的意思。代码如下：
![picture2](https://github.com/SYSULuxiaodan/SE2016_14353221/blob/master/picture42.png)

！[picture3](https://github.com/SYSULuxiaodan/SE2016_14353221/blob/master/picture43.png)

class A中和classB中分别定义了方法A和方法B。两个class方法一样，class A方法中传入的是资源B，调用资源B,向控制台输出“Inside A。last()" classB中传入的值资源A,调用资源B向控制台上输出"Inside B.last()"。
接下来是运行主函数，Runnable（）在这个函数中，首先新定义A，B两个方法。然后定义一个新线程 t,当线程t 开始start使，线程t进入等待队列等待count时间后调用a.menthoA(b)，然后线程继续执行，调用b.methodA(a),当它们在执行的过程中，如果无法及时的释放a和b，那么就会导致methodA要请求的资源被MenthodB占有，menthodB要请求的资源被methodA占有。这样就形成了一种环路关系，导致了死锁产生。

###三、实验感想
这次实验主要是理解死锁产生的原理和条件。因为上个学期学过操作系统，对这一块的内容还是比较熟悉的。所以整个实验下来对死锁的还是比较理解，实验操作过程相对来说还是比较顺畅的。而这次也同时让我们巩固了下之前操作系统的内容。不过，因为在ubuntu上，调了count的值和循环次数，不管怎么调也还是死锁不了。然后在windows下运行，也跟个人电脑有关系，据我了解，很多同学二三十次就死锁了。不过我运行一直到173次才死锁，这跟整个电脑的环境都有关系。代码的实验结果理论上是一进去就死锁了。但由于各种因素的影响，会对情况有影响。我觉得有时间可以深入了解下哪些原因对运行死锁有影响。


